---
layout: post
title:  "A Most Byzantine Forum"
date:   2016-10-17 05:28:39 +0000
---


Today, I am presenting my latest project that blends history with modern Web app technology: [`A Most Byzantine Forum`](https://github.com/lair001/a-most-byzantine-forum).  Built using [`Sinatra`](https://en.wikipedia.org/wiki/Sinatra_(software)), [`ActiveRecord`](http://guides.rubyonrails.org/active_record_basics.html) and [`Bootstrap`](https://en.wikipedia.org/wiki/Bootstrap_(front-end_framework)) and tested using [`Rspec`](https://en.wikipedia.org/wiki/RSpec) and [`Capybara`](https://en.wikipedia.org/wiki/Capybara_(software)), this project is huge jump from [`QuickTicker`](https://github.com/lair001/qticker) and [`Super Prompt`](https://github.com/lair001/super-prompt).  It also gives fans of the [Roman Empire](https://en.wikipedia.org/wiki/Roman_Empire) a platform to discuss their favorite Roman topics and to roleplay.

A Most Byzantine Forum is lightweight forum software themed after the late Roman Empire (retroactively renamed the [Byzantine Empire](https://en.wikipedia.org/wiki/Byzantine_Empire) by historians).  It is loosely modeled after [`XenoForo`](https://en.wikipedia.org/wiki/XenForo) forums like this [one](https://forum.paradoxplaza.com/forum/index.php).

The premise is simple.  Users can create an account.  Upon logging in, they are taken to a listing of threads.  By clicking a `Create` button in the navbar, they can create a new thread.  Links consisting of a thread's title take them to a listing of the thread's posts.  In this listing, the post's content and information about the user who created it is displayed.  By clicking on a `Create` button in the navbar, they can add a post to the thread.  Links consisting of a user's username takes them to the user's profile.  This profile contains information about the user's account along with a listing of all posts that the user has created.  They can also access a listing of all users through a navbar button.  

There are also special users, adminstrators and moderators.  Administrators can alter the account information of any user.  Moderators can edit and delete content created by any user.

In short, it behaves like a typical forum.  The Roman elements come from the color scheme and a tribute page for [Constantine XI](https://en.wikipedia.org/wiki/Constantine_XI_Palaiologos).  The moderators may also choose to limit discussion to Roman topics or roleplay.

The real action takes place under the hood.  At the heart of the app is an [`SQL`](https://en.wikipedia.org/wiki/SQL) database with tables that represent users, threads and posts.  A [table relation](https://en.wikipedia.org/wiki/Relation_(database)) scheme is implemented wherein the posts table has [`foreign keys`](https://en.wikipedia.org/wiki/Foreign_key) for a user and a thread and acts as a [`join table`](https://en.wikipedia.org/wiki/Associative_entity) for the users and threads tables.  In this way, a post belongs to a user and a thread, a user has many posts, a table has many posts, a user has many threads through posts, and a thread has many users through posts.

This database is managed by `ActiveRecord`.  It represents the tables as Ruby classes called [models](http://guides.rubyonrails.org/active_model_basics.html).  The table relations are explicitly stated in the model definitions.  In this way, `ActiveRecord` is taught how to join the tables, and the process of making the `SQL` queries necessary to find a post's user, a thread's posts, or a user's threads is simplified to calling methods on the models.  For example, `User.find_by(username: "Nick").threads` will return all threads where a user with a username of `Nick`.  In the background, ActiveRecord used the posts table to join the users and threads tables, found all rows of the joined table where the username column value equals `Nick`, extracted the columns for the threads table, and constructed an array of Thread models where each model is populated with data from a row in the joined table.  All in all, `ActiveRecord` makes complicated `SQL` queries a breeze.

`ActiveRecord` can also do [validations](http://guides.rubyonrails.org/active_record_validations.html) that are performed before a model is persisted to the database.  The app uses a variety of both stock and custom validations.  For instance, the User model validates that the username, email, and password are present and are formatted correctly.  If a model fails validation, it is not persisted and errors are added to the model.  The app uses this functionality to display validation errors beneath forms.

Next is `Sinatra` itself.  `Sinatra` uses controllers to draw routes, implement logic for a route, and render views.  This is a bit different from [`Rails`](https://en.wikipedia.org/wiki/Ruby_on_Rails) which seperates route drawing into a configuration file.  The app uses [`RESTful`](https://en.wikipedia.org/wiki/Representational_state_transfer) conventions to divide [`CRUD`](https://en.wikipedia.org/wiki/Create,_read,_update_and_delete) actions between routes and their associated views.  The end result is that the app is structured very similarly to a typical `Rails` `CRUD` application.

Finally, there are the tests.  On the surface, Capybara appears to be unnecessarily finicky by drawing a distinction where [`HTTP verbs`](http://www.restapitutorial.com/lessons/httpmethods.html), such as `get`, `post`, `patch`, `put`, and `delete`, do not render the view while [`visit`](http://www.rubydoc.info/github/jnicklas/capybara/Capybara%2FSession%3Avisit) does.  What this means is that you cannot implement [`CSS selector`](https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Getting_started/Selectors) tests while testing the view.  This is increadibly frustrating at first, and I spent a lot of time using [`pry`](http://pryrepl.org/) to figure out what was going on.  However, Capybara is trying to encourage to divide your tests along [`MVC`](https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller) lines.  By doing so, you learn a lot about MVC architecture.

Since `ActiveRecord` respresents models as Ruby classes and database queries as instance and class methods.  As a result, you only need `Rspec` to test models.  These tests are focused around the database , the `ActiveRecord` interface with the database including validations and relationships, and any custom methods you have have attached to the model.  Capybara's `HTTP verbs` are used to test routes and the controller.  These tests are focused on the logic behind processing a HTTP request.  Capybara's `visit` method is used to test the views.  These tests involve the [`HTML`](https://en.wikipedia.org/wiki/HTML) and [`CSS`](https://en.wikipedia.org/wiki/Cascading_Style_Sheets) elements present in the server's response.  As a result, you end up with a modular test structure that closely mirrors your app's `MVC` structure.

That is all I have for today.  I hope you enjoyed reading.  Feel free to send comments and feedback to lair002@gmail.com.  You can find `A Most Byzantine Forum` [here](https://github.com/lair001/a-most-byzantine-forum).
