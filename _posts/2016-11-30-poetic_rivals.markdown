---
layout: post
title:  "Poetic Rivals"
date:   2016-11-30 01:35:33 +0000
---


Over the past three weeks, I have tackled my first [`Ruby on Rails`](https://en.wikipedia.org/wiki/Ruby_on_Rails) project, [`Poetic Rivals`](https://github.com/lair001/poetic-rivals).  It certainly has plenty of conveniences compared to `Sinatra` such as generators, form helpers, and conventions that enable you to automagically setup routes, controllers, and views.  It even has some nice features for `Rspec` and `Capybara` tests where the testing DSL changes depending on the type of tests you are writing.  However, the convenience of `Rails` lead me to tackle a more ambitious project than last time.

I leveraged the [`Assest Pipeline`](http://guides.rubyonrails.org/asset_pipeline.html) powered by [`Sprockets`](https://github.com/rails/sprockets) to [`DRY`](https://en.wikipedia.org/wiki/Don't_repeat_yourself) up my stylesheets with [`Sass`](http://sass-lang.com/) so that my projects can now be rethemed by tweaking a handful of variables.  I also used [`Factory Girl`](https://github.com/thoughtbot/factory_girl) and [`Faker`](https://github.com/stympy/faker) to dynamically generate test and seed data.  I even explored [`Rack's`](https://github.com/rack/rack) env hash and parsed Rails's `rake routes` output  to create some helpers that will be useful in projects to come.  However, the true centerpiece of `Poetic Rivals` is its collection of 8 tables and the dozens of relations that emerge from these tables.

In Poetic Rivals, would be poets compete for the adoration of fans.  Users can write poems and comment on each other's poems, but the real action lies in the scoring mechanics.  Poems can be upvoted or downvoted, and Fandoms and Rivalries can be declared with large scoring implications for the targets.  Consequently, the schema for the project, which can be found [here](https://github.com/lair001/poetic-rivals/blob/master/db/schema.rb), is a bit Byzantine.

Perhaps the most notable feature of this schema are the myriad foreign keys that do not clearly map on to a table.  This is due to all of the different roles that a user can play.  A user can be an author, a commentator, a voter, a fan, a rival, an idol, or a victim.  Indeed, two tables, `fan_idols` and `rival_victims` joins the `users` table on to itself.  A look at the declared ActiveRecord associations should clarify what is going on, but there are nearly 30 of them so I won't copy them into this blog post.  You may view them in Poetic Rivals's [models](https://github.com/lair001/poetic-rivals/tree/master/app/models) folder.

A lambda, `-> { distinct }` is used in the has many and has many through associations.  This tells ActiveRecord to use the SQL statement `SELECT DISTINCT` instead of `SELECT`.  By default, has many and has many associations can return duplicate records.  If user b comments multiple times on user a's poems, then, by default, user a's commentators association will return multiple instances of user b.  Although this behavior may be desirable in some domains, `Poetic Rivals` is not interested in duplicates.  Therefore, `-> { distinct }` is used to eliminate them.

Although a user's score can be computed using an SQL query, `Poetic Rivals` caches it as a users table column which is updated via callbacks in the FanIdols, RivalVictims, and PoemVoters models.  Without this cache, an SQL query to order users by score would need to join the users, fan_idols, rival_victims, poems, and poem_voters tables.  In other words, `Poetic Rivals` would need to access all of the records of a join comprising 5 tables every time the server received a request for the leaderboard.  Therefore, adding this extra column greatly reduces strain on the database.  A user model does include a method to refresh a user's score using the these five tables in case a user's score is inaccurate.  If `Poetic Rivals` ever went live, I would include a Rake task to refresh the scores of all users during server maintenance.

Finally, `Poetic Rivals` uses a slew of relatively simple queries to report all sorts of fun statistics.  A user's show page includes the user's fan, idol, rival and victim counts while a genre's show page includes the genre's author and poem counts.  This time around, I sought to bring game-like elements to a forum-like environment in order to appeal to the audience's creative and competitive tendencies.  There might not be much of audience for SQL antics, but at least a few people should find a popularity contest revolving around poetry of questionable quality at least mildly amusing.
