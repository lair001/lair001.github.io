---
layout: post
title:  "Hashing It Out"
date:   2016-09-26 03:14:08 +0000
---


Web developers love [hashes](https://en.wikipedia.org/wiki/Hash_table).  Most of my prior programming experience consisted of [Fortran 95](https://en.wikipedia.org/wiki/Fortran#Fortran_95) projects that solved math and physics problems for high school and college.  Fortran 95 does not have hashes unless you actively seek out to create hash-like constructs through awkward [means](https://www.experts-exchange.com/questions/24486275/Implementation-of-an-hashtable-in-fortran-95.html).  Fortunately, Fortran loves [arrays](https://en.wikipedia.org/wiki/Array_data_type), and hashes can be conceptualized as an abstracted array.  Whereas an array maps a subset of consecutive integers including zero [onto](https://en.wikipedia.org/wiki/Surjective_function) a set of values, a hash maps an arbitrary set of objects onto a set of values.  In other words, an array is a type of hash.

Hashes are useful because arbitrary datasets can be organized as a hash or a nested hash.  For instance, a [table](https://en.wikipedia.org/wiki/Table_(database)) can be represented as a nested hash.  The [keys](https://en.wikipedia.org/wiki/Unique_key) of this hash are row id integers while the values are hashes.  These "hash values" representing individual rows each consist of keys that map onto a value of a column at a particular row.  Suppose we implement such a nested hash in Ruby.  The row ids are symbols as are the column keys in each "hash value."  We store the nested hash in a variable called `table`.  We can access the value of an age column in row 10 with `table[:10][:age]`.  If we stored our table in a [SQL](https://en.wikipedia.org/wiki/SQL) database, we could access the same value with the query `SELECT age FROM table WHERE id = 10;`  In other words, a well structured nested hash is essentially a database.

Similarly, [`Active Record`](http://guides.rubyonrails.org/active_record_basics.html) respresents databases using a combination of class structure and hashes.  Tables are classes and rows are instances of classes.  The attributes of an instance of a class are columns.  Attributes of an instance are created and assigned dynamically through [mass assignment](https://code.tutsplus.com/tutorials/mass-assignment-rails-and-you--net-31695) by passing a hash into a [constructor](http://www.rubyist.net/~slagell/ruby/objinitialization.html).  The keys of the hash become instance variables, and the value of each instance variable is the value associated with the corresponding hash key.  In this way, Active Record is able to provide a convenient Ruby-based framework for managing SQL databases.

This brings us back to `Quick Ticker`.  In essence, I built a very lightweight version of Active Record.  My [Scraper]()https://github.com/lair001/stocks-cli-gem/blob/master/lib/scraper.rb class packages data into a nested hash.  The attributes of instances of Stock, Desc, and Quote are [dynamically created and populated](https://github.com/lair001/stocks-cli-gem/blob/master/lib/table.rb) after an instance of Stock has [distributed](https://github.com/lair001/stocks-cli-gem/blob/master/lib/stock.rb) the appropriate hashes out of the nested hash to itself, its instance of Desc, and its instance of Quote.  In this case, the key-value pairs of the nested hash represent tables rather than rows.

Anything you could do nested hash you could also do with a nested array.  However, array indexes do not generally make for descriptive keys.  For instance, you may need to remember that `table[9][2]` is the value of the age column at row 10.  This will make your software project harder to develop and maintain.

That is all I have for now.  I hope you found this post enjoyable and informative!
